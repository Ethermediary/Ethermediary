module.exports = errorHandler

var Domain = require('domain')

// The default handler; logs the error with console.error( ) and
// sends a plain server error message.
function defaultHandler (req, res, err) {
  console.error(err)

  res.writeHead(500, {'Content-Type': 'text/plain'})
  res.end('Server error.\n')
}

/**
 * errorHandler(req, res, handler, notFatal) handles error for the current
 * request and response. handler is a function which gets passed the
 * request, the response, and the error, and may do whatever they want
 * with it. The default behaviour is to exit the process in which the
 * error occurred; if notFatal is true, this behaviour is overidden.
 *
 * @param {Request} req
 * @param {Response} res
 * @param {Function} handler
 * @param {Boolean} notFatal
 */
function errorHandler (req, res, handler, notFatal) {

  handler = handler || defaultHandler

  var dom = Domain.create()
  dom.add(req)
  dom.add(res)
  dom.on('error', function (err) {
    delete err.domain

    function cleanUp () {
      dom.exit()
      dom.dispose()

      if (!notFatal) process.exit(1)
    }

    var t = setTimeout(cleanUp, 1000)

    res.on('finish', function () {
      clearTimeout(t)

      // The response was not being sent over HTTPS when exiting too
      // soon; hence, process.nextTick(). req.client.server doesn't
      // work over HTTPS either, so we'll have to make do with
      // process.exit().
      process.nextTick(cleanUp)
    })

    try {
      handler(req, res, err)
    } catch (e) {
      defaultHandler(req, res, e)
    }
  })

  dom.enter()
  process.nextTick(dom.exit)
}